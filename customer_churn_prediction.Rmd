---
title:  'XGBoost Algorithm'
subtitle: 'INFO 523'
author:
- name: Student -  [Gayathri Renganathan, Mohit Rakesh Taparia]
  affiliation: [iSchool]
- name: Instructor -  Cristian Rom√°n-Palacios
  affiliation: School of Information, University of Arizona, Tucson, AZ
tags: [R, RStudio, Final Project - XGBoost Algorithm]
output: html_document

---

```{r}
library(readxl)
library(dplyr)
library(caret)
library(xgboost)
library(ggplot2)
library(GGally)
library(fastDummies)
```

The case study references the Telecom customer churn dataset from the EMPRESS-i on https://archive.ics.uci.edu/dataset/563/iranian+churn+dataset

The read_excel() method loads the dataset stored in the Excel format. 

```{r}
file_path <- "Data/Customer Churn.csv"
customerInfo <- read.csv(file_path,  sep = ",", header = TRUE)
```


```{r}
head(customerInfo,10)
```

```{r}
summary(customerInfo)
```

Checking for null Values
```{r}
sum(is.na(customerInfo))
```
Remove Age column,as Age.Group column is used to infer the same details
```{r}
customerInfo$Age.Group <- factor(customerInfo$Age.Group)
```

Updating the Age.Group as factors as they indicate a category
```{r}
customerInfo <- customerInfo %>% select(-c(Age))
```


Count of Number of customer who got churned or not
```{r}
customerInfo %>% group_by(Churn) %>% summarise(n=n()) %>% arrange(desc(n))
```

Plotting churn count in the dataset.
```{r}
ggplot(customerInfo, aes(x = Churn, y = Charge..Amount, fill = factor(Churn))) +
  geom_boxplot() +
  labs(x = "Churn", y = "Charge Amount", fill = "Churn", title = "Charge Amount Distribution by Churn Status") +
  theme_minimal()
```
Observation1: 
using this Count plot,  target variable is checked for data imbalance  (if there are more number of churn customers than customers who wont churn or vice versa)
There is some data imbalance, as the number of churn consumers is significantly lower than the number of customers that will not churn


Count plot of Age Group to see the distribution of customers across Age
```{r}
ggplot(customerInfo, aes(x = Age.Group, fill = factor(Age.Group))) +
  geom_density(aes(y = ..count..), alpha = 0.6) +
  labs(x = "Age Group", y = "Count", title = "Density Plot of Age Group Distribution with Count", fill = "Age Group") +
  theme_minimal()
```
Observation2: 
There are more customer in the middle age group (2 and 3)


Count plot of Age Group to see the distribution of customers across Age
```{r}
ggplot(customerInfo, aes(x = Charge..Amount, fill = factor(Charge..Amount))) +
  geom_bar() + 
  scale_fill_brewer(palette = "Set3") +  # Apply a custom color palette
  geom_text(stat='count', aes(label=..count..), vjust=-0.5, size=3.5) +  # Add count labels on top of the bars
  labs(x = "Charge Amount", y = "Count", fill = "Charge Amount", title = "Distribution of Customers by Charge Amount") +
  theme_minimal() +  # Apply a minimalistic theme for clean presentation
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Center and style the title
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.position = "right",  # Position the legend on the right
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9)
  )
```
Observation3: 
Charge amount is an ordinal attribute with lowest value being 0 and highest being 9
The charge amount of 0 has the highest count, and the count decreases with the charge amount.


Distribution of Churn count across age group
```{r}
ggplot(customerInfo, aes(x = Age.Group, fill = factor(Churn))) + 
  geom_bar(position = "dodge", color = "black") +  # Grouped bar plot with black border
  scale_fill_manual(values = c("#00AFBB", "#E7B800")) +  # Custom colors for the Churn groups
  geom_text(stat = 'count', aes(label = ..count..), vjust = -0.3, position = position_dodge(0.9), size = 3.5) +  # Adding count labels
  labs(x = "Age Group", y = "Count", fill = "Churn", title = "Churn Distribution Across Age Groups") +
  theme_minimal() +  # Apply a minimalistic theme
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Center and bold the title
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.position = "right",  # Position the legend on the right
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9)
  ) 
```
Observation:
Customer in the Middle age group(2 and 3) are churned more compared to other age group


Distribution of Churn count across status 
```{r}
# Create a table of counts for Status and Churn
status_churn_table <- table(customerInfo$Status, customerInfo$Churn)

# Convert the table to a data frame for easier plotting
status_churn_df <- as.data.frame(status_churn_table)
colnames(status_churn_df) <- c("Status", "Churn", "Count")

# Plotting the heatmap
ggplot(status_churn_df, aes(x = factor(Status), y = factor(Churn), fill = Count)) + 
  geom_tile(color = "white") +  # Create the heatmap tiles with white borders
  scale_fill_gradient(low = "#FFCCCC", high = "#990000") +  # Use a gradient color scale
  labs(x = "Status", y = "Churn", fill = "Count", title = "Heatmap of Churn Distribution Across Status") +
  scale_x_discrete(labels = c("1" = "Active", "2" = "Inactive")) +  # Replace the numeric labels with meaningful ones
  theme_minimal() +  # Apply a minimalistic theme
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Center and bold the title
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 12),
    legend.position = "right",  # Position the legend on the right
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 9)
  )


```
Observation:
Status is ordinal attribute; 1 - Active ; 2 - Inactive
Inactive customers are more likely to be churned, compared to the Active customers.

Pair plot of all features
```{r}
ggpairs(customerInfo[,c("Call..Failure", "Complains", "Subscription..Length", "Charge..Amount","Seconds.of.Use","Frequency.of.use","Age.Group", "Status")])
```
Observation:

Frequency_of_use and seconds_of_use is strongly correlated.

Using correlation matrix to find the correlation
```{r}
library(corrplot)

cor <- cor(customerInfo)
corrplot(cor, method="pie")
```
Observation:
 
 There is a positive correlation with Frequency_of_sms and customer_value

Dropping the correlated columns
```{r}
customerInfo <- customerInfo %>% select(-c(Frequency.of.use))
```

Scaling Continuous Variable
```{r}
customerInfo_int <- customerInfo[,-c(2,8,9,10,12)]
customerInfo_int <- data.frame(scale(customerInfo_int))
```

Creating factors for Categorical Data
```{r}
customerInfo$Complains <- factor(customerInfo$Complains)
customerInfo$Age.Group <- factor(customerInfo$Age.Group)
customerInfo$Tariff.Plan <- factor(customerInfo$Tariff.Plan)
customerInfo$Status <- factor(customerInfo$Status)
#customerInfo$Churn <- factor(customerInfo$Churn)
customerInfo_scaled <- customerInfo %>% 
                  select(c(2,8,9,10,12)) %>%
                  cbind(customerInfo_int)
```
 

Creating Dummy variable for Categorical Data
```{r}
sparse_matrix <- model.matrix(Churn ~ ., data = customerInfo_scaled)[,-1]
customerInfo_final <-  customerInfo_scaled %>% select(c("Churn")) %>% cbind(sparse_matrix)
```

Scaling Continuous Variable
Split Train and Test Data

```{r}
target <- "Churn"
features <- setdiff(names(customerInfo_final), target)
set.seed(123)
trainIndex <- createDataPartition(customerInfo_final[[target]], p = 0.8, 
                                  list = FALSE, 
                                  times = 1)
dataTrain <- customerInfo_final[trainIndex, ]
dataTest <- customerInfo_final[-trainIndex, ]
xTrain <- dataTrain[, features]
yTrain <- dataTrain[[target]]
xTest <- dataTest[, features]
yTest <- dataTest[[target]]

```



setting up a grid that tunes both these parameters, and also the eta (learning rate).
```{r}
xgb_grid = expand.grid(
nrounds = 1000,
eta = c(0.1, 0.05, 0.01),
max_depth = c(2, 3, 4, 5, 6),
gamma = 0,
colsample_bytree=1,
min_child_weight=c(1, 2, 3, 4 ,5),
subsample=1
)
```

The next step is to let caret find the best hyperparameter values (using 5 fold cross validation).
```{r}
set.seed(27042018)
my_control <-trainControl(method="cv", number=5)
xgb_caret <- train(Churn~., data=dataTrain, method='xgbTree', trControl= my_control, tuneGrid=xgb_grid) 
xgb_caret$bestTune
```
```{r}
# put our testing & training data into two seperates Dmatrixs objects
dtrain <- xgb.DMatrix(data = as.matrix(xTrain), label= yTrain)
dtest <- xgb.DMatrix(data = as.matrix(xTest), label= yTest)
best_tune_param<-list(
        objective = "reg:logistic",
        eval_metric = "error",
        eta=0.05, #default = 0.3
        gamma=0,
        max_depth=6, #default=6
        min_child_weight=1, #default=1
        subsample=1,
        colsample_bytree=1
)
```

 cross validation to determine the best number of rounds (for the given set of parameters).
```{r}
xgbcv <- xgb.cv( params = best_tune_param, data = dtrain, nrounds = 500, nfold = 5, showsd = T, stratified = T, print_every_n = 40, early_stopping_rounds = 10, maximize = F)
```
```{r}
#train the model using the best iteration found by cross validation
xgb_mod <- xgb.train(data = dtrain, params=best_tune_param, nrounds = 252,
                       watchlist = list(train = dtrain, eval = dtest))
```
 
```{r}
preds <- predict(xgb_mod, dtest)
predictions_XGB <- exp(XGBpred) #need to reverse the log to the real values
head(predictions_XGB)
```
 
 